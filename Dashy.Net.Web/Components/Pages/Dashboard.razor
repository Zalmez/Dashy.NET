@page "/"
@inject ILogger<Dashboard> Logger
@inject IJSRuntime JSRuntime
@inject DashboardClient DashboardClient
@inject DashboardStateService DashboardState
@inject ViewOptionsService ViewOptions
@implements IDisposable

<PageTitle>@DashboardState.Config?.Title</PageTitle>

@if (DashboardState.Config is null)
{
    <p><em>Loading dashboard...</em></p>
}
else
{
    @if (ViewOptions.IsEditMode)
    {
        <div class="add-section-container">
            <button class="btn btn-primary" @onclick="OpenAddSectionModal">
                <i class="fas fa-plus"></i> Add New Section
            </button>
        </div>
    }

    <div class="dashboard-container">
        <div class="sections-wrapper">
            <SortableList Items="FilteredSections.ToList()"
                          OnUpdate="async args => await OnSectionOrderChanged(args.oldIndex, args.newIndex)"
                          Context="currentSection"
                          class="sections-wrapper-inner"
                          Sort="ViewOptions.IsEditMode">
                <div class="section-item" @key="currentSection">
                    <div class="section-container" id="section-@currentSection.Id">
                        <div class="section-header" @onclick="() => ToggleSectionCollapse(currentSection.Id)">
                            <div class="section-header-left">
                                <i class="fas fa-chevron-down section-chevron @(_collapsedSections.Contains(currentSection.Id) ? "collapsed" : "")"></i>
                                @if (!string.IsNullOrWhiteSpace(currentSection.Icon))
                                {
                                    <i class="@currentSection.Icon section-icon"></i>
                                }
                                <h2>@currentSection.Name</h2>
                            </div>
                            @if (ViewOptions.IsEditMode)
                            {
                                <div class="section-edit-controls" @onclick:stopPropagation="true">
                                    <button class="edit-btn" title="Edit Section" @onclick="() => OpenEditSectionModal(currentSection)"><i class="fas fa-pencil-alt"></i></button>
                                    <button class="delete-btn" title="Delete Section" @onclick="() => HandleSectionDeleted(currentSection)">
                                        <i class="fas fa-trash-alt"></i>
                                    </button>
                                </div>
                            }
                        </div>
                        <div class="items-wrapper @GetItemsContainerClass(currentSection.Id)">
                            <SortableList Items="currentSection.Items"
                                          OnUpdate="async args => await OnItemOrderChanged(currentSection, (args.oldIndex, args.newIndex))"
                                          Context="item"
                                          Class="item-list"
                                          Sort="ViewOptions.IsEditMode">
                                <div class="item" @key="item">
                                    @switch (item.Widget?.ToLower() ?? "static-link")
                                    {
                                        case "static-link":
                                            <StaticLinkWidget Item="item" OnItemDeleted="HandleItemDeleted" OnItemEdited="() => OpenEditModal(item)" />
                                            break;
                                        case "clock":
                                            <ClockWidget Item="item" />
                                            break;
                                        case "weather":
                                            <WeatherWidget Item="item" />
                                            break;
                                        default:
                                            <UnknownWidget Widget="@item.Widget" />
                                            break;
                                    }
                                </div>
                            </SortableList>
                            @if (ViewOptions.IsEditMode && !_collapsedSections.Contains(currentSection.Id))
                            {
                                <AddItemButton OnClick="() => OpenCreateModal(currentSection.Id)" />
                            }
                        </div>
                    </div>
                </div>
            </SortableList>
        </div>
    </div>

    <Modal Title="@_itemModalTitle" IsOpen="@_isItemModalOpen" OnClose="CloseItemModal">
        @if (_currentItemToEdit is not null)
        {
            <ItemEditor EditModel="_currentItemToEdit" OnSave="HandleSaveItem" OnCancel="CloseItemModal" />
        }
    </Modal>
    <Modal Title="@(_sectionToEdit is null ? "Add New Section" : $"Edit '{_sectionToEdit?.Name}'")" IsOpen="@_isSectionModalOpen" OnClose="CloseSectionModal">
        @if (_sectionModel is not null)
        {
            <EditForm Model="_sectionModel" OnValidSubmit="() => HandleSaveSection(_sectionModel)">
                <DataAnnotationsValidator />
                <div class="form-group">
                    <label for="section-name">Section Name</label>
                    <InputText id="section-name" class="form-control" @bind-Value="_sectionModel.Name" />
                    <ValidationMessage For="@(() => _sectionModel.Name)" />
                </div>
                <div class="form-group">
                    <label for="section-icon">Icon (e.g., "fas fa-tools")</label>
                    <InputText id="section-icon" class="form-control" @bind-Value="_sectionModel.Icon" />
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" @onclick="CloseSectionModal">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save Section</button>
                </div>
            </EditForm>
        }
    </Modal>
}

@code {
    private bool _isItemModalOpen = false;
    private string _itemModalTitle = "";
    private ItemEditModel? _currentItemToEdit;

    private bool _isSectionModalOpen = false;
    private SectionVm? _sectionToEdit;
    private CreateSectionDto? _sectionModel;
    private HashSet<int> _collapsedSections = new();

    private bool _isDisposed;

    private IEnumerable<SectionVm> FilteredSections =>
        DashboardState.Config?.Sections.Where(section =>
            string.IsNullOrWhiteSpace(ViewOptions.SearchTerm) ||
            section.Name.Contains(ViewOptions.SearchTerm, StringComparison.OrdinalIgnoreCase) ||
            section.Items.Any(item => item.Title.Contains(ViewOptions.SearchTerm, StringComparison.OrdinalIgnoreCase))
        ) ?? Enumerable.Empty<SectionVm>();

    protected override void OnInitialized()
    {
        DashboardState.OnConfigLoaded += OnConfigLoadedHandler;
        ViewOptions.OnChange += HandleOptionsChanged;
    }

    private void HandleOptionsChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var config = await DashboardClient.GetConfigAsync();
            if (_isDisposed) return;
            DashboardState.SetConfig(config);
        }
    }

    private void OnConfigLoadedHandler()
    {
        if (_isDisposed) return;
        InvokeAsync(StateHasChanged);
    }

    private void OpenCreateModal(int sectionId)
    {
        _itemModalTitle = "Add New Item";
        _currentItemToEdit = new ItemEditModel { SectionId = sectionId, Widget = "static-link" };
        _isItemModalOpen = true;
    }

    private void OpenEditModal(ItemVm item)
    {
        _itemModalTitle = $"Edit '{item.Title}'";
        _currentItemToEdit = new ItemEditModel(item);
        _isItemModalOpen = true;
    }

    private void OpenAddSectionModal()
    {
        if (DashboardState.Config is null) return;
        _sectionToEdit = null;
        _sectionModel = new CreateSectionDto { DashboardId = DashboardState.Config.Id };
        _isSectionModalOpen = true;
    }

    private void OpenEditSectionModal(SectionVm section)
    {
        _sectionToEdit = section;
        _sectionModel = new CreateSectionDto
        {
            Name = section.Name,
            Icon = section.Icon,
            DashboardId = section.DashboardId
        };
        _isSectionModalOpen = true;
    }

    private void CloseSectionModal()
    {
        _isSectionModalOpen = false;
        _sectionToEdit = null;
        _sectionModel = null;
    }

    private void ToggleSectionCollapse(int sectionId)
    {
        if (ViewOptions.IsEditMode) return;
        if (_collapsedSections.Contains(sectionId))
        {
            _collapsedSections.Remove(sectionId);
        }
        else
        {
            _collapsedSections.Add(sectionId);
        }
    }

    private void CloseItemModal()
    {
        _isItemModalOpen = false;
        _currentItemToEdit = null;
    }

    private async Task HandleSaveSection(CreateSectionDto sectionToSave)
    {
        bool success;
        if (_sectionToEdit is not null)
        {
            var updateDto = new UpdateSectionDto(sectionToSave.Name, sectionToSave.Icon);
            success = await DashboardClient.Sections.UpdateAsync(_sectionToEdit.Id, updateDto);
        }
        else
        {
            success = await DashboardClient.Sections.CreateAsync(sectionToSave);
        }
        if (_isDisposed) return;
        if (success)
        {
            var newConfig = await DashboardClient.GetConfigAsync();
            DashboardState.SetConfig(newConfig);
        }
        CloseSectionModal();
    }

    private async Task OnItemOrderChanged(SectionVm section, (int oldIndex, int newIndex) args)
    {
        var items = section.Items.ToList();
        var movedItem = items[args.oldIndex];
        items.RemoveAt(args.oldIndex);
        items.Insert(args.newIndex, movedItem);

        var orderedIds = items.Select(i => i.Id).ToList();
        var dto = new ReorderItemsDto(orderedIds);
        var success = await DashboardClient.Items.ReorderAsync(dto);
        if (!success && !_isDisposed)
        {
            var newConfig = await DashboardClient.GetConfigAsync();
            DashboardState.SetConfig(newConfig);
        }

    }

    private async Task OnSectionOrderChanged(int oldIndex, int newIndex)
    {
        if (DashboardState.Config is null) return;

        var sections = FilteredSections.ToList();
        var movedSection = sections[oldIndex];
        sections.RemoveAt(oldIndex);
        sections.Insert(newIndex, movedSection);

        var orderedIds = sections.Select(s => s.Id).ToList();
        var dto = new ReorderSectionsDto(orderedIds);
        var success = await DashboardClient.Sections.ReorderAsync(dto);
        if (!success)
        {
            var newConfig = await DashboardClient.GetConfigAsync();
            DashboardState.SetConfig(newConfig);
        }
    }

    private async Task HandleSaveItem(ItemEditModel itemToSave)
    {
        bool success;
        if (itemToSave.Id > 0)
        {
            var updateDto = itemToSave.ToUpdateDto();
            success = await DashboardClient.Items.UpdateAsync(itemToSave.Id, updateDto);
        }
        else
        {
            var createDto = itemToSave.ToCreateDto();
            success = await DashboardClient.Items.CreateAsync(createDto);
        }

        if (success)
        {
            var newConfig = await DashboardClient.GetConfigAsync();
            DashboardState.SetConfig(newConfig);
        }

        CloseItemModal();
    }
    private async Task HandleItemDeleted(ItemVm itemToDelete)
    {
        var success = await DashboardClient.Items.DeleteAsync(itemToDelete.Id);
        if (success)
        {
            var config = DashboardState.Config;
            if (config is null) return;
            var section = config.Sections.FirstOrDefault(s => s.Items.Any(i => i.Id == itemToDelete.Id));
            if (section is not null)
            {
                var item = section.Items.FirstOrDefault(i => i.Id == itemToDelete.Id);
                if (item is not null) section.Items.Remove(item);
            }
        }
    }

    private async Task HandleSectionDeleted(SectionVm sectionToDelete)
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete the entire '{sectionToDelete.Name}' section and all of its items?");
        if (!confirmed) return;
        var success = await DashboardClient.Sections.DeleteAsync(sectionToDelete.Id);
        if (success)
        {
            DashboardState.Config?.Sections.Remove(sectionToDelete);
        }
    }

    private string GetItemsContainerClass(int sectionId)
    {
        if (_collapsedSections.Contains(sectionId))
            return "collapsed";

        return "layout-" + ViewOptions.CurrentLayout.ToString().ToLower();
    }

    public void Dispose()
    {
        _isDisposed = true;
        ViewOptions.OnChange -= HandleOptionsChanged;
        DashboardState.OnConfigLoaded -= OnConfigLoadedHandler;
    }
}