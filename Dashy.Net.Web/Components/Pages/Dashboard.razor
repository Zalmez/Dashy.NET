@page "/"
@page "/dashboard/{Id:int?}"
@using Dashy.Net.Web.Helpers
@using Dashy.Net.Web.Components.Shared
@using Dashy.Net.Shared.Models
@using Dashy.Net.Web.Services
@using Microsoft.FluentUI.AspNetCore.Components
@inject ILogger<Dashboard> Logger
@inject IJSRuntime JSRuntime
@inject DashboardClient DashboardClient
@inject DashboardStateService DashboardState
@inject ViewOptionsService ViewOptions
@inject EventSubscriptionManager SubscriptionManager
@implements IDisposable

<PageTitle>@DashboardState.Config?.Title</PageTitle>

@if (DashboardState.Config is null)
{ 
    @if (_isInitializing)
    {
        <p><span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> <span>Initializing dashboard...</span></p>
    }
    else if (!string.IsNullOrEmpty(_initError))
    {
        <div class="alert alert-danger" style="margin-top:1rem;">@_initError</div>
        <button class="btn btn-primary" @onclick="InitializeDashboard" disabled="@_isInitializing">
            <span><i class="fas fa-rocket"></i> Retry Initialization</span>
        </button>
    }
    else
    {
        <p><em>No dashboard found.</em></p>
    }
}
else
{
    <div class="dashboard-container">
        @if (ViewOptions.IsEditMode && !DashboardState.Config.UseContainerWidgets) @* TODO: Remove this part for 1.0 release(noted as a breaking change)*@
        {
            <div class="add-section-container">
                <button class="btn btn-primary" @onclick="OpenAddSectionModal">
                    <i class="fas fa-plus"></i> Add New Section
                </button>
            </div>
        }

        @if (DashboardState.Config.UseContainerWidgets)
        {   
            <FluentDragContainer TItem="ItemVm" class="dashboard-drag-container" OnDropEnd="HandleDashboardDropEnd">
                <DashboardFlatView Items="GetFlattenedRootItems()" IsEditMode="ViewOptions.IsEditMode"
                                   OnReordered="HandleFlatReordered"
                                   OnAddItem="OpenAddRootItem"
                                   OnAddItemToContainer="@(EventCallback.Factory.Create<int>(this, OpenAddChildItem))" />
            </FluentDragContainer>
        }
        else
        {
            <div class="dashboard-grid">
                @foreach (var currentSection in FilteredSections)
                {
                    <div class="section-item @GetSectionSizeClass(currentSection)" @key="currentSection.Id">
                        <div class="section-container @GetLayoutClass()" id="section-@currentSection.Id">
                            <div class="section-header" @onclick="() => ToggleSectionCollapse(currentSection.Id)">
                                <div class="section-header-left">
                                    <i class="fas fa-chevron-down section-chevron @(_collapsedSections.Contains(currentSection.Id) ? "collapsed" : "")"></i>
                                    @if (!string.IsNullOrWhiteSpace(currentSection.Icon))
                                    {
                                        <i class="@currentSection.Icon section-icon"></i>
                                    }
                                    <h2>@currentSection.Name</h2>
                                </div>
                                @if (ViewOptions.IsEditMode)
                                {
                                    <div class="section-edit-controls" @onclick:stopPropagation="true">
                                        <button class="edit-btn" title="Edit Section" @onclick="() => OpenEditSectionModal(currentSection)"><i class="fas fa-pencil-alt"></i></button>
                                        <button class="delete-btn" title="Delete Section" @onclick="() => HandleSectionDeleted(currentSection)">
                                            <i class="fas fa-trash-alt"></i>
                                        </button>
                                    </div>
                                }
                            </div>
                            <div class="items-wrapper @GetItemsContainerClass(currentSection.Id)">
                                @foreach (var currentItem in currentSection.Items)
                                {
                                    <div class="item" @key="currentItem.Id">
                                        @switch (currentItem.Widget?.ToLower() ?? "static-link")
                                        {
                                            case "static-link":
                                                <StaticLinkWidget Item="currentItem" OnItemDeleted="HandleItemDeleted" OnItemEdited="() => OpenEditModal(currentItem)" />
                                                break;
                                            case "clock":
                                                <ClockWidget Item="currentItem" OnItemDeleted="HandleItemDeleted" OnItemEdited="() => OpenEditModal(currentItem)"/>
                                                break;
                                            case "weather":
                                                <WeatherWidget Item="currentItem" OnItemDeleted="HandleItemDeleted" OnItemEdited="() => OpenEditModal(currentItem)" />
                                                break;
                                            case "public ip":
                                                <PublicIPWidget Item="currentItem" OnItemDeleted="HandleItemDeleted" OnItemEdited="() => OpenEditModal(currentItem)" />
                                                break;
                                            case "rss feed":
                                                <RssWidget Item="currentItem" OnItemDeleted="HandleItemDeleted" OnItemEdited="() => OpenEditModal(currentItem)" />
                                                break;
                                            case "vulnerability feed":
                                                <VulnerabilityFeedWidget Item="currentItem" OnItemDeleted="HandleItemDeleted" OnItemEdited="() => OpenEditModal(currentItem)" />
                                                break;
                                            case "section-container":
                                                <SectionContainerWidget Item="currentItem"
                                                                        OnAddChildToContainer="@(EventCallback.Factory.Create<int>(this, OpenAddChildItem))" />
                                                break;
                                            default:
                                                <UnknownWidget Item="currentItem" Widget="@currentItem.Widget" OnItemDeleted="HandleItemDeleted" OnItemEdited="() => OpenEditModal(currentItem)" />
                                                break;
                                        }
                                    </div>
                                }
                                @if (ViewOptions.IsEditMode && !_collapsedSections.Contains(currentSection.Id))
                                {
                                    <AddItemButton OnClick="() => OpenCreateModal(currentSection.Id)" />
                                }
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
    </div>

    <Modal Title="@_itemModalTitle" IsOpen="@_isItemModalOpen" OnClose="CloseItemModal">
        @if (_currentItemToEdit is not null)
        {
            <ItemEditor EditModel="_currentItemToEdit" OnSave="HandleSaveItem" OnCancel="CloseItemModal" />
        }
    </Modal>
    <Modal Title="@(_sectionToEdit is null ? "Add New Section" : $"Edit '{_sectionToEdit?.Name}'")" IsOpen="@_isSectionModalOpen" OnClose="CloseSectionModal">
        @if (_sectionModel is not null)
        {
            <EditForm Model="_sectionModel" OnValidSubmit="() => HandleSaveSection(_sectionModel)">
                <DataAnnotationsValidator />
                <div class="form-group">
                    <label for="section-name">Section Name</label>
                    <InputText id="section-name" class="form-control" @bind-Value="_sectionModel.Name" />
                    <ValidationMessage For="@(() => _sectionModel.Name)" />
                </div>
                <div class="form-group">
                    <label for="section-icon">Icon (e.g., "fas fa-tools")</label>
                    <InputText id="section-icon" class="form-control" @bind-Value="_sectionModel.Icon" />
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" @onclick="CloseSectionModal">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save Section</button>
                </div>
            </EditForm>
        }
    </Modal>
}

@code {
    [Parameter] public int? Id { get; set; }
    
    private bool _isItemModalOpen = false;
    private string _itemModalTitle = "";
    private ItemEditModel? _currentItemToEdit;

    private bool _isSectionModalOpen = false;
    private SectionVm? _sectionToEdit;
    private CreateSectionDto? _sectionModel;
    private HashSet<int> _collapsedSections = new();

    private bool _isDisposed;

    private bool _isInitializing = false;
    private string? _initError;

    private int? _pendingContainerId;

    private IEnumerable<SectionVm> FilteredSections =>
        DashboardState.Config?.Sections.Where(section =>
            string.IsNullOrWhiteSpace(ViewOptions.SearchTerm) || SectionMatchesSearch(section, ViewOptions.SearchTerm)
        ) ?? Enumerable.Empty<SectionVm>();

    private bool SectionMatchesSearch(SectionVm section, string term)
    {
        if (section.Name.Contains(term, StringComparison.OrdinalIgnoreCase)) return true;
        if (section.Items.Any(item => item.Title.Contains(term, StringComparison.OrdinalIgnoreCase))) return true;
        var containerItems = section.Items.Where(i => string.Equals(i.Widget, "section-container", StringComparison.OrdinalIgnoreCase));
        foreach (var container in containerItems)
        {
            var childItems = section.Items.Where(i => i.ParentItemId == container.Id);
            if (childItems.Any(c => c.Title.Contains(term, StringComparison.OrdinalIgnoreCase))) return true;
        }
        return false;
    }

    protected override void OnInitialized()
    {
        SubscriptionManager.AddSubscription(() => DashboardState.OnConfigLoaded -= OnConfigLoadedHandler);
        SubscriptionManager.AddSubscription(() => ViewOptions.OnChange -= HandleOptionsChanged);

        DashboardState.OnConfigLoaded += OnConfigLoadedHandler;
        ViewOptions.OnChange += HandleOptionsChanged;
    }

    protected override async Task OnParametersSetAsync()
    {
        var dashboardId = Id ?? 1;
        
        await ViewOptions.InitializeAsync(dashboardId);
        
        if (DashboardState.Config?.Id != dashboardId)
        {
            var config = await DashboardClient.GetConfigAsync(dashboardId);
            if (!_isDisposed)
            {
                await InvokeAsync(() => DashboardState.SetConfig(config));
            }
        }
    }

    private void HandleOptionsChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var dashboardId = Id ?? 1;
            var config = await DashboardClient.GetConfigAsync(dashboardId);
            if (_isDisposed) return;
            if (config is null && !_isInitializing)
            {
                await InitializeDashboard();
            }
            else
            {
                await InvokeAsync(() => DashboardState.SetConfig(config));
            }
        }
    }

    private void OnConfigLoadedHandler()
    {
        if (_isDisposed) return;
        InvokeAsync(StateHasChanged);
    }

    private void OpenCreateModal(int sectionId, int? parentItemId = null)
    {
        _itemModalTitle = parentItemId is null ? "Add New Item" : "Add Child Item";
        _currentItemToEdit = new ItemEditModel { SectionId = sectionId, Widget = "static-link", ParentItemId = parentItemId };
        _isItemModalOpen = true;
    }

    private void OpenAddChildItem(int containerItemId)
    {
        var sectionId = DashboardState.Config?.Sections.FirstOrDefault(s => s.Items.Any(i => i.Id == containerItemId))?.Id ?? 0;
        if (sectionId == 0) return;
        OpenCreateModal(sectionId, containerItemId);
    }

    private void OpenEditModal(ItemVm item)
    {
        _itemModalTitle = $"Edit '{item.Title}'";
        _currentItemToEdit = new ItemEditModel(item);
        _isItemModalOpen = true;
    }

    private async Task<int> EnsureDefaultSectionAsync()
    {
        var config = DashboardState.Config;
        if (config is null) return 0;
        var existing = config.Sections.FirstOrDefault();
        if (existing is not null) return existing.Id;
        var createDto = new CreateSectionDto { Name = "__root__", Icon = null, DashboardId = config.Id };
        var success = await DashboardClient.Sections.CreateAsync(createDto);
        if (!success || _isDisposed) return 0;
        var newConfig = await DashboardClient.GetConfigAsync(Id);
        if (_isDisposed) return 0;
        await InvokeAsync(() => DashboardState.SetConfig(newConfig));
        return newConfig?.Sections.FirstOrDefault()?.Id ?? 0;
    }

    private void OpenAddSectionModal()
    {
        if (DashboardState.Config is null) return;
        if (DashboardState.Config.UseContainerWidgets)
        {
            InvokeAsync(async () => await OpenAddRootItem());
            return;
        }
        _sectionToEdit = null;
        _sectionModel = new CreateSectionDto { DashboardId = DashboardState.Config.Id };
        _isSectionModalOpen = true;
    }

    private void OpenEditSectionModal(SectionVm section)
    {
        _sectionToEdit = section;
        _sectionModel = new CreateSectionDto
        {
            Name = section.Name,
            Icon = section.Icon,
            DashboardId = section.DashboardId
        };
        _isSectionModalOpen = true;
    }

    private void CloseSectionModal()
    {
        _isSectionModalOpen = false;
        _sectionToEdit = null;
        _sectionModel = null;
    }

    private void ToggleSectionCollapse(int sectionId)
    {
        if (ViewOptions.IsEditMode) return;
        if (_collapsedSections.Contains(sectionId))
        {
            _collapsedSections.Remove(sectionId);
        }
        else
        {
            _collapsedSections.Add(sectionId);
        }
    }

    private void CloseItemModal()
    {
        _isItemModalOpen = false;
        _currentItemToEdit = null;
        _pendingContainerId = null;
    }

    private async Task HandleSaveSection(CreateSectionDto sectionToSave)
    {
        if (_isDisposed) return;
        if (DashboardState.Config?.UseContainerWidgets == true && (DashboardState.Config.Sections?.Any() ?? false))
        {
            CloseSectionModal();
            return;
        }
        bool success;
        if (_sectionToEdit is not null)
        {
            var updateDto = new UpdateSectionDto(sectionToSave.Name, sectionToSave.Icon);
            success = await DashboardClient.Sections.UpdateAsync(_sectionToEdit.Id, updateDto);
        }
        else
        {
            success = await DashboardClient.Sections.CreateAsync(sectionToSave);
        }
        if (_isDisposed) return;
        if (success)
        {
            var dashboardId = Id ?? 1;
            var newConfig = await DashboardClient.GetConfigAsync(dashboardId);
            if (_isDisposed) return;
            await InvokeAsync(() => DashboardState.SetConfig(newConfig));
        }
        CloseSectionModal();
    }

    private async Task HandleSaveItem(ItemEditModel itemToSave)
    {
        if (_isDisposed) return;
        bool success;
        if (itemToSave.Id > 0)
        {
            var updateDto = itemToSave.ToUpdateDto();
            success = await DashboardClient.Items.UpdateAsync(itemToSave.Id, updateDto);
        }
        else
        {
            var createDto = itemToSave.ToCreateDto();
            success = await DashboardClient.Items.CreateAsync(createDto);
        }

        if (_isDisposed) return;
        if (success)
        {
            var newConfig = await DashboardClient.GetConfigAsync(Id);
            if (_isDisposed) return;
            await InvokeAsync(() => DashboardState.SetConfig(newConfig));
        }

        CloseItemModal();
    }

    private async Task HandleItemDeleted(ItemVm itemToDelete)
    {
        if (_isDisposed) return;
        var success = await DashboardClient.Items.DeleteAsync(itemToDelete.Id);
        if (_isDisposed) return;
        if (success)
        {
            var config = DashboardState.Config;
            if (config is null) return;
            var section = config.Sections.FirstOrDefault(s => s.Items.Any(i => i.Id == itemToDelete.Id));
            if (section is not null)
            {
                var item = section.Items.FirstOrDefault(i => i.Id == itemToDelete.Id);
                if (item is not null) section.Items.Remove(item);
            }
        }
    }

    private async Task HandleSectionDeleted(SectionVm sectionToDelete)
    {
        if (_isDisposed) return;
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete the entire '{sectionToDelete.Name}' section and all of its items?");
        if (_isDisposed || !confirmed) return;
        var success = await DashboardClient.Sections.DeleteAsync(sectionToDelete.Id);
        if (_isDisposed) return;
        if (success)
        {
            DashboardState.Config?.Sections.Remove(sectionToDelete);
        }
    }

    private string GetItemsContainerClass(int sectionId)
    {
        if (_collapsedSections.Contains(sectionId))
            return "collapsed";

        return "layout-" + ViewOptions.CurrentLayout.ToString().ToLower();
    }

    private string GetLayoutClass()
    {
        return "layout-" + ViewOptions.CurrentLayout.ToString().ToLower();
    }

    private string GetSectionSizeClass(SectionVm section)
    {
        var itemCount = section.Items.Count;
        var currentItemSize = ViewOptions.CurrentItemSize;
        var isVerticalLayout = ViewOptions.CurrentLayout == LayoutOrientation.Vertical;
        
        if (itemCount == 0)
            return "section-size-auto";
        if (isVerticalLayout)
        {
            return currentItemSize switch
            {
                ItemSize.Large when itemCount >= 1 => "section-size-medium", 
                ItemSize.Medium when itemCount >= 2 => "section-size-small",
                _ => "section-size-auto"
            };
        }

        if (currentItemSize == ItemSize.Large)
        {
            return itemCount switch
            {
                >= 4 => "section-size-large",
                >= 2 => "section-size-medium",
                _ => "section-size-auto"
            };
        }
        
        if (currentItemSize == ItemSize.Medium)
        {
            return itemCount switch
            {
                >= 6 => "section-size-large",
                >= 4 => "section-size-medium",
                _ => "section-size-auto"
            };
        }
        return itemCount switch
        {
            >= 8 => "section-size-medium",
            _ => "section-size-auto"
        };
    }

    private async Task InitializeDashboard()
    {
        _isInitializing = true;
        _initError = null;
        StateHasChanged();
        try
        {
            var success = await DashboardClient.SeedDashboardAsync();
            if (!success)
            {
                _initError = "Failed to initialize dashboard. Please try again or check the server logs.";
            }
            else
            {
                var dashboardId = Id ?? 1;
                var config = await DashboardClient.GetConfigAsync(dashboardId);
                if (_isDisposed) return;
                await InvokeAsync(() => DashboardState.SetConfig(config));
            }
        }
        catch (Exception ex)
        {
            _initError = $"Error: {ex.Message}";
        }
        finally
        {
            _isInitializing = false;
            StateHasChanged();
        }
    }

    private List<ItemVm> GetFlattenedRootItems()
    {
        var result = new List<ItemVm>();
        if (DashboardState.Config is null) return result;
        foreach (var section in DashboardState.Config.Sections)
        {
            foreach (var item in section.Items.OrderBy(i => i.SectionId).ThenBy(i => i.Id))
            {
                if (item.ParentItemId is null)
                {
                    result.Add(item);
                }
            }
        }
        if (!string.IsNullOrWhiteSpace(ViewOptions.SearchTerm))
        {
            var term = ViewOptions.SearchTerm;
            result = result.Where(i => i.Title.Contains(term, StringComparison.OrdinalIgnoreCase)).ToList();
        }
        return result;
    }

    private async Task HandleFlatReordered(List<int> orderedIds)
    {
        if (orderedIds.Count == 0) return;
        var allItems = DashboardState.Config?.Sections.SelectMany(s => s.Items).ToDictionary(i => i.Id);
        if (allItems is null) return;
        var orderedItems = orderedIds
            .Select(id => allItems.TryGetValue(id, out var itm) ? itm : null)
            .Where(itm => itm is not null && itm.ParentItemId is null)
            .ToList()!;

        var groups = orderedItems
            .GroupBy(i => (i.SectionId, Parent: (int?)null))
            .ToList();

        var okAll = true;
        foreach (var grp in groups)
        {
            var scopedIds = grp.Select(i => i.Id).ToList();
            var dto = new ReorderItemsScopedDto(grp.Key.SectionId, grp.Key.Parent, scopedIds);
            var ok = await DashboardClient.Items.ReorderScopedAsync(dto);
            if (!ok) okAll = false;
        }

        if (!okAll || _isDisposed) return;
        var newConfig = await DashboardClient.GetConfigAsync(Id);
        if (_isDisposed) return;
        await InvokeAsync(() => DashboardState.SetConfig(newConfig));
    }

    private async Task OpenAddRootItem()
    {
        var sectionId = DashboardState.Config?.Sections.FirstOrDefault()?.Id ?? 0;
        if (sectionId == 0)
        {
            sectionId = await EnsureDefaultSectionAsync();
        }
        if (sectionId == 0) return;
        OpenCreateModal(sectionId);
    }

    private static bool IsContainer(ItemVm item)
        => item.Widget?.Contains("container", StringComparison.OrdinalIgnoreCase) == true;

    private async void HandleDashboardDropEnd(FluentDragEventArgs<ItemVm> e)
    {
        if (_isDisposed || !ViewOptions.IsEditMode) return;
        var source = e.Source?.Item;
        var target = e.Target?.Item; // may be null when dropping on root blank drop zone
        if (source is null) return;
        var config = DashboardState.Config;
        if (config is null) return;

        // Root blank drop => un-nest
        if (target is null)
        {
            if (source.ParentItemId is null)
                return; // already root
            var okUnnest = await DashboardClient.Items.MoveAsync(new MoveItemDto
            {
                ItemId = source.Id,
                NewParentItemId = null,
                ClearParent = true
            });
            if (!okUnnest || _isDisposed) return;
            var cfgRoot = await DashboardClient.GetConfigAsync(Id);
            if (_isDisposed) return;
            await InvokeAsync(() => DashboardState.SetConfig(cfgRoot));
            return;
        }

        if (source.Id == target.Id) return;
        var sourceParent = source.ParentItemId;
        var targetParent = target.ParentItemId;
        var targetIsContainer = IsContainer(target);

        // Case 1: dropping onto a container => nest into that container
        if (targetIsContainer)
        {
            var okNest = await DashboardClient.Items.MoveAsync(new MoveItemDto
            {
                ItemId = source.Id,
                NewSectionId = target.SectionId != source.SectionId ? target.SectionId : null,
                NewParentItemId = target.Id
            });
            if (!okNest || _isDisposed) return;
            var cfg = await DashboardClient.GetConfigAsync(Id);
            if (_isDisposed) return;
            await InvokeAsync(() => DashboardState.SetConfig(cfg));
            return;
        }

        // Case 2: same parent reorder (root or inside a container)
        if (source.SectionId == target.SectionId && sourceParent == targetParent)
        {
            var siblings = config.Sections.SelectMany(s => s.Items)
                .Where(i => i.SectionId == target.SectionId && i.ParentItemId == targetParent)
                .ToList();
            var srcIndex = siblings.FindIndex(i => i.Id == source.Id);
            var tgtIndex = siblings.FindIndex(i => i.Id == target.Id);
            if (srcIndex >= 0 && tgtIndex >= 0 && srcIndex != tgtIndex)
            {
                var itm = siblings[srcIndex];
                siblings.RemoveAt(srcIndex);
                siblings.Insert(tgtIndex, itm);
                var ids = siblings.Select(i => i.Id).ToList();
                var okReorder = await DashboardClient.Items.ReorderScopedAsync(new ReorderItemsScopedDto(target.SectionId, targetParent, ids));
                if (!okReorder || _isDisposed) return;
                var cfg = await DashboardClient.GetConfigAsync(Id);
                if (_isDisposed) return;
                await InvokeAsync(() => DashboardState.SetConfig(cfg));
            }
            return;
        }

        // Case 3: cross-parent move (un-nest to target's parent or between containers)
        {
            var moveDto = new MoveItemDto
            {
                ItemId = source.Id,
                NewSectionId = source.SectionId == target.SectionId ? null : target.SectionId,
                NewParentItemId = targetParent,
                ClearParent = targetParent is null
            };
            var okMove = await DashboardClient.Items.MoveAsync(moveDto);
            if (!okMove || _isDisposed) return;

            // After moving, reorder in the target scope to place source near target
            var cfg = await DashboardClient.GetConfigAsync(Id);
            if (_isDisposed) return;
            var siblings = cfg?.Sections.SelectMany(s => s.Items)
                .Where(i => i.SectionId == target.SectionId && i.ParentItemId == targetParent)
                .ToList() ?? new List<ItemVm>();
            var srcIndex = siblings.FindIndex(i => i.Id == source.Id);
            var tgtIndex = siblings.FindIndex(i => i.Id == target.Id);
            if (srcIndex >= 0 && tgtIndex >= 0 && srcIndex != tgtIndex)
            {
                var itm = siblings[srcIndex];
                siblings.RemoveAt(srcIndex);
                siblings.Insert(tgtIndex, itm);
                var ids = siblings.Select(i => i.Id).ToList();
                var okOrder = await DashboardClient.Items.ReorderScopedAsync(new ReorderItemsScopedDto(target.SectionId, targetParent, ids));
                if (!okOrder || _isDisposed) return;
                cfg = await DashboardClient.GetConfigAsync(Id);
                if (_isDisposed) return;
            }
            await InvokeAsync(() => DashboardState.SetConfig(cfg));
        }
    }

    public void Dispose()
    {
        SubscriptionManager.Dispose();
        _isDisposed = true;
    }
}