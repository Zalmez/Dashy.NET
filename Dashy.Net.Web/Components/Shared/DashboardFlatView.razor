@using Dashy.Net.Shared.Models
@using Dashy.Net.Web.Components.Shared
@inject Dashy.Net.Web.Services.DragContextService DragContext
@inject Dashy.Net.Web.Clients.DashboardClient DashboardClient
@inject Dashy.Net.Web.Services.DashboardStateService DashboardState

<FluentDropZone TItem="ItemVm" Droppable="@IsEditMode" Draggable="false" StopPropagation="true" class="flat-root-drop-zone">
    @if (Items is null || Items.Count == 0)
    {
        <div class="empty-flat-grid" tabindex="0">No widgets yet.</div>
    }
    else
    {
        <div class="flat-grid" @onkeydown="OnKeyDown">
            @foreach (var item in Items)
            {
                var isContainer = item.Widget?.Contains("container", StringComparison.OrdinalIgnoreCase) == true;
                var css = $"sortable-item {(isContainer ? "sortable-container" : "sortable-leaf")}";
                <FluentDropZone TItem="ItemVm" Item="item" Data="item" class="@css" Draggable="@IsEditMode" Droppable="@IsEditMode" StopPropagation="true" tabindex="0" @onfocus="() => OnItemFocus(item)">
                    @RenderItem(item)
                </FluentDropZone>
            }
        </div>
    }
    @if (IsEditMode)
    {
        <div class="flat-grid-actions">
            <AddItemButton OnClick="AddRootWidget" />
        </div>
    }
</FluentDropZone>
    
@code {
    [Parameter] public List<ItemVm> Items { get; set; } = new();
    [Parameter] public bool IsEditMode { get; set; }
    [Parameter] public EventCallback<List<int>> OnReordered { get; set; }
    [Parameter] public EventCallback OnAddItem { get; set; }
    [Parameter] public EventCallback<int> OnAddItemToContainer { get; set; }

    private int _focusedIndex = -1;

    private RenderFragment<ItemVm> RenderItem => item => builder =>
    {
        switch ((item.Widget?.ToLower()) ?? "static-link")
        {
            case "static-link":
                builder.OpenComponent<StaticLinkWidget>(0);
                builder.AddAttribute(1, "Item", item);
                builder.CloseComponent();
                break;
            case "clock":
                builder.OpenComponent<ClockWidget>(0);
                builder.AddAttribute(1, "Item", item);
                builder.CloseComponent();
                break;
            case "weather":
                builder.OpenComponent<WeatherWidget>(0);
                builder.AddAttribute(1, "Item", item);
                builder.CloseComponent();
                break;
            case "public ip":
                builder.OpenComponent<PublicIPWidget>(0);
                builder.AddAttribute(1, "Item", item);
                builder.CloseComponent();
                break;
            case "rss feed":
                builder.OpenComponent<RssWidget>(0);
                builder.AddAttribute(1, "Item", item);
                builder.CloseComponent();
                break;
            case "vulnerability feed":
                builder.OpenComponent<VulnerabilityFeedWidget>(0);
                builder.AddAttribute(1, "Item", item);
                builder.CloseComponent();
                break;
            case "section-container":
                builder.OpenComponent<SectionContainerWidget>(0);
                builder.AddAttribute(1, "Item", item);
                builder.AddAttribute(2, "OnAddChildToContainer", EventCallback.Factory.Create<int>(this, id => OnAddItemToContainer.InvokeAsync(id)));                
                builder.CloseComponent();
                break;
            default:
                builder.OpenComponent<UnknownWidget>(0);
                builder.AddAttribute(1, "Item", item);
                builder.AddAttribute(2, "Widget", item.Widget);
                builder.CloseComponent();
                break;
        }
    };

    private Task AddRootWidget() => OnAddItem.InvokeAsync();

    private void OnItemFocus(ItemVm item)
    {
        _focusedIndex = Items.FindIndex(i => i.Id == item.Id);
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (!IsEditMode) return;
        if (_focusedIndex < 0) return;
        if (e.Key == "ArrowLeft" || e.Key == "ArrowUp")
        {
            var newIndex = Math.Max(0, _focusedIndex - 1);
            if (newIndex != _focusedIndex)
            {
                var itm = Items[_focusedIndex];
                Items.RemoveAt(_focusedIndex);
                Items.Insert(newIndex, itm);
                _focusedIndex = newIndex;
                await OnReordered.InvokeAsync(Items.Select(i => i.Id).ToList());
            }
        }
        else if (e.Key == "ArrowRight" || e.Key == "ArrowDown")
        {
            var newIndex = Math.Min(Items.Count - 1, _focusedIndex + 1);
            if (newIndex != _focusedIndex)
            {
                var itm = Items[_focusedIndex];
                Items.RemoveAt(_focusedIndex);
                Items.Insert(newIndex, itm);
                _focusedIndex = newIndex;
                await OnReordered.InvokeAsync(Items.Select(i => i.Id).ToList());
            }
        }
    }
}
