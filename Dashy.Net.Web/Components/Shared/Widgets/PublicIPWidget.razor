@inherits WidgetBase
@inject IJSRuntime JSRuntime
@using System.Text.Json
@using System.Text.Json.Serialization

<WidgetChrome Title="@Item.Title"
              Icon="@Item.Icon"
              SizeClass="@GetItemSizeClass()"
              ColorClass="@GetTileColorClass()"
              IsEditMode="@ViewOptions.IsEditMode"
              OnEdit="OnEditClick"
              OnDelete="OnDeleteClick">
    @if (_isLoading)
    {
        <div class="tile-icon"><i class="fas fa-spinner fa-spin"></i></div>
        <div class="tile-title">Loading...</div>
    }
    else if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="tile-icon"><i class="fas fa-exclamation-triangle"></i></div>
        <div class="tile-title error-message">@_errorMessage</div>
    }
    else
    {
        <div class="tile-icon"><i class="fas fa-wifi"></i></div>
        <div class="tile-title">@_publicIP</div>
        @if (ViewOptions.CurrentItemSize == ItemSize.Large || ViewOptions.CurrentItemSize == ItemSize.Medium)
        {
            <div class="tile-description">
                @if (!string.IsNullOrEmpty(_flagUrl))
                {
                    <img src="@_flagUrl" alt="Country Flag" style="width: 16px; height: auto; margin-right: 0.25rem;" />
                }
                @_zipcode, @_location
            </div>
        }
    }
</WidgetChrome>

@code {
    private string? _publicIP;
    private string? _location;
    private int? _zipcode;
    private string? _flagUrl;
    private bool _isLoading = true;
    private string? _errorMessage;
    private string _selectedProvider => GetOption("provider") ?? "ipapi.co";
    private string _apiKey => GetOption("apikey") ?? "";

    private Dictionary<string, Func<Task>> _providers = new();

    private string GetTileColorClass()
    {
        var hash = Item.Title.GetHashCode();
        var colors = new[] { "blue", "green", "purple", "orange", "red", "pink", "teal" };
        return colors[Math.Abs(hash) % colors.Length];
    }

    protected override async Task OnInitializedAsync()
    {
        base.OnInitialized();
        _providers = new Dictionary<string, Func<Task>>
        {
            { "ipapi.co", FetchFromIpApi },
            { "ipgeolocation.io", FetchFromIpGeolocation }
        };
        await FetchData();
        if (IsDisposed) return;
        _isLoading = false;
    }

    private async Task FetchData()
    {
        _isLoading = true;
        _errorMessage = null;
        _publicIP = null;
        _location = null;
        _flagUrl = null;

        if (_providers.TryGetValue(_selectedProvider, out var fetchMethod))
        {
            await fetchMethod();
            if (IsDisposed) return;
        }
        else
        {
            _errorMessage = "Invalid provider selected.";
        }
    }

    private async Task OnEditClick() => await OnItemEdited.InvokeAsync();

    private async Task OnDeleteClick()
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete '{Item.Title}'?");
        if (IsDisposed) return;
        if (confirmed) { await OnItemDeleted.InvokeAsync(Item); }
    }

    private async Task FetchFromIpApi()
    {
        try
        {
            var httpClient = new HttpClient();
            httpClient.DefaultRequestHeaders.Add("User-Agent", "ipapi.co/#c-sharp-v1.03");
            var response = await httpClient.GetFromJsonAsync<PublicIPResponse>("https://ipapi.co/json/");
            if (IsDisposed) return;
            if (response is not null)
            {
                _publicIP = response.Ip;
                _location = $"{response.City}, {response.CountryName}";
                _flagUrl = $"https://flagcdn.com/{response.CountryCode.ToLower()}.svg";
            }
            else { _errorMessage = "Failed to fetch IP details from ipapi.co."; }
        }
        catch (Exception)
        {
            if (IsDisposed) return;
            _errorMessage = "Error fetching IP";
        }
    }

    private async Task FetchFromIpGeolocation()
    {
        try
        {
            var httpClient = new HttpClient();
            var response = await httpClient.GetFromJsonAsync<IpGeolocationResponse>($"https://api.ipgeolocation.io/v2/ipgeo?apiKey={_apiKey}&fields=location");
            if (IsDisposed) return;
            if (response is not null)
            {
                _publicIP = response.Ip;
                _location = $"{response.location.City}, {response.location.CountryName}";
                _flagUrl = $"https://flagcdn.com/{response.location.CountryCode.ToLower()}.svg";
                _zipcode = response.location.ZipCode;
            }
            else { _errorMessage = "Failed to fetch IP details from ipgeolocation.io."; }
        }
        catch (Exception)
        {
            if (IsDisposed) return;
            _errorMessage = "Error fetching IP";
        }
    }

    private class PublicIPResponse { public string Ip { get; set; } = string.Empty; public string City { get; set; } = string.Empty; public string CountryName { get; set; } = string.Empty; public string CountryCode { get; set; } = string.Empty; }
    private class IpGeolocationResponse { [JsonPropertyName("ip")] public string Ip { get; set; } = string.Empty; [JsonPropertyName("location")] public Location location { get; set; } = new(); }
    private class Location { [JsonPropertyName("city")] public string City { get; set; } = string.Empty; [JsonPropertyName("country_name")] public string CountryName { get; set; } = string.Empty; [JsonPropertyName("country_code2")] public string CountryCode { get; set; } = string.Empty; [JsonPropertyName("country_flag")] public string CountryFlag { get; set; } = string.Empty; [JsonPropertyName("zipcode")] public int ZipCode { get; set; } = 0; }
}
