@inherits WidgetBase
@inject IJSRuntime JSRuntime
@inject ILogger<StaticLinkWidget> Logger
@inject NavigationManager NavManager
@implements IDisposable

<WidgetChrome Title="@Item.Title"
              Icon="@Item.Icon"
              SizeClass="@GetItemSizeClass()"
              ColorClass="@GetTileColorClass()"
              IsEditMode="@ViewOptions.IsEditMode"
              OnEdit="OnEditClick"
              OnDelete="OnDeleteClick"
              OnClick="HandleTileClick">
    @if (ViewOptions.CurrentItemSize == ItemSize.Large && !string.IsNullOrWhiteSpace(Description))
    {
        <div class="tile-description">@Description</div>
    }
</WidgetChrome>

@code {

    private string? Url => GetOption("url");
    private string? Description => GetOption("Description");
    private string LinkTarget => GetOption("target") ?? "_self";

    private void HandleTileClick()
    {
        if (!ViewOptions.IsEditMode && !string.IsNullOrWhiteSpace(Url))
        {
            if (LinkTarget == "_blank")
            {
                _ = JSRuntime.InvokeVoidAsync("open", Url, "_blank");
            }
            else
            {
                NavManager.NavigateTo(Url);
            }
        }
    }

    private string GetTileColorClass()
    {
        var hash = Item.Title.GetHashCode();
        var colors = new[] { "blue", "green", "purple", "orange", "red", "pink", "teal" };
        return colors[Math.Abs(hash) % colors.Length];
    }

    private async Task OnDeleteClick()
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete '{Item.Title}'?");
        if (IsDisposed) return;
        if (confirmed)
        {
            await OnItemDeleted.InvokeAsync(Item);
        }
    }

    private async Task OnEditClick()
    {
        await OnItemEdited.InvokeAsync();
    }
}
