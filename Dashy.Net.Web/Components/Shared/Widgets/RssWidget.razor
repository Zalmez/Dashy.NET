@using System.Xml
@using System.Threading
@inherits WidgetBase
@inject IJSRuntime JSRuntime
@inject ILogger<RssWidget> Logger
@inject NavigationManager NavManager
@implements IDisposable

<div class="item-card-wrapper rss-widget @GetItemSizeClass()" data-widget-type="RssWidget">
    <WidgetChrome Title="@Item.Title"
                  Icon="@Item.Icon"
                  SizeClass="@GetItemSizeClass()"
                  ColorClass=""
                  IsEditMode="@ViewOptions.IsEditMode"
                  OnEdit="OnEditClick"
                  OnDelete="OnDeleteClick">
        @switch (ViewOptions.CurrentItemSize)
        {
            case ItemSize.Small:
                <ul class="rss-feed-items">
                    @foreach (var feedItem in _rssFeedItems)
                    {
                        <li>
                            <div class="rss-item-header">
                                <h6>@feedItem.Title</h6>
                            </div>
                            <a href="@feedItem.Link" target="_blank" rel="noopener noreferrer" class="rss-continue-reading">Continue Reading <i class="fa-solid fa-arrow-up-right-from-square"></i></a>
                        </li>
                    }
                </ul>
                break;

            case ItemSize.Medium:
                <ul class="rss-feed-items rss-grid">
                    @foreach (var feedItem in _rssFeedItems)
                    {
                        <li>
                            <div class="rss-item-header">
                                <h5>@feedItem.Title</h5>
                            </div>
                            <p class="rss-publish-date">@feedItem.PublishDate.ToString("ddd, MMM dd yyyy")</p>
                            <p class="rss-description">@feedItem.Description.Substring(0, Math.Min(feedItem.Description.Length, 100))...</p>
                            <a href="@feedItem.Link" target="_blank" rel="noopener noreferrer" class="rss-continue-reading">Continue Reading <i class="fa-solid fa-arrow-up-right-from-square"></i></a>
                        </li>
                    }
                </ul>
                break;

            case ItemSize.Large:
                <ul class="rss-feed-items">
                    @foreach (var feedItem in _rssFeedItems)
                    {
                        <li>
                            <div class="rss-item-header">
                                <h4>@feedItem.Title</h4>
                            </div>
                            <p class="rss-publish-date">@feedItem.PublishDate.ToString("ddd, MMM dd yyyy")</p>
                            <p class="rss-description">@feedItem.Description</p>
                            <a href="@feedItem.Link" target="_blank" rel="noopener noreferrer" class="rss-continue-reading">Continue Reading <i class="fa-solid fa-arrow-up-right-from-square"></i></a>
                            <hr class="rss-item-separator" />
                        </li>
                    }
                </ul>
                break;
        }
    </WidgetChrome>
</div>

@code {
    private IEnumerable<RssFeedItem> _rssFeedItems = Enumerable.Empty<RssFeedItem>();
    private int? maxItems => int.TryParse(GetOption("MaxItems"), out var result) ? result : null;
    private string maxWidth => GetOption("maxSize") ?? "100%";
    private Timer? _refreshTimer;
    private int refreshIntervalMinutes => int.TryParse(GetOption("RefreshInterval"), out var result) ? result : 5;
    private readonly HttpClient _httpClient = new();

    protected override async Task OnInitializedAsync()
    {
        base.OnInitialized();
        _httpClient.Timeout = TimeSpan.FromSeconds(10);
        await LoadRssFeedItems();
        StartAutoRefresh();
    }

    private async Task LoadRssFeedItems()
    {
        _rssFeedItems = await GetRssFeedItems();
        Logger.LogInformation($"Loaded {@_rssFeedItems.Count()} RSS feed items from {GetOption("FeedUrl")}");
        if (!IsDisposed)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void StartAutoRefresh()
    {
        if (refreshIntervalMinutes > 0)
        {
            _refreshTimer = new Timer(async _ =>
            {
                if (!IsDisposed)
                {
                    try { await LoadRssFeedItems(); }
                    catch (Exception ex) { Logger.LogError(ex, "Error during RSS feed refresh"); }
                }
            }, null, TimeSpan.FromMinutes(refreshIntervalMinutes), TimeSpan.FromMinutes(refreshIntervalMinutes));
        }
    }

    private async Task<IEnumerable<RssFeedItem>> GetRssFeedItems()
    {
        var feedUrl = GetOption("FeedUrl");
        if (string.IsNullOrWhiteSpace(feedUrl)) { Logger.LogWarning("FeedUrl is not set for RssWidget."); return Enumerable.Empty<RssFeedItem>(); }
        var feedItems = new List<RssFeedItem>();
        try
        {
            var response = await _httpClient.GetStringAsync(feedUrl);
            if (IsDisposed) return Enumerable.Empty<RssFeedItem>();
            var xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(response);
            var items = xmlDoc.SelectNodes("//item");
            if (items != null)
            {
                var count = 0;
                foreach (XmlNode item in items)
                {
                    if (count >= maxItems) break;
                    count++;
                    var titleNode = item.SelectSingleNode("title");
                    var linkNode = item.SelectSingleNode("link");
                    var descriptionNode = item.SelectSingleNode("description") ?? item.SelectSingleNode("content:encoded");
                    if (titleNode != null && linkNode != null)
                    {
                        feedItems.Add(new RssFeedItem
                        {
                            Title = HtmlDecode(StripHtml(titleNode.InnerText)),
                            Link = linkNode.InnerText,
                            Description = HtmlDecode(StripHtml(descriptionNode?.InnerText ?? string.Empty)),
                            PublishDate = DateTime.TryParse(item.SelectSingleNode("pubDate")?.InnerText, out var pubDate) ? pubDate : DateTime.MinValue
                        });
                    }
                }
            }
            if (feedItems.Count == 0) Logger.LogWarning($"No items found in RSS feed from {feedUrl}");
            return feedItems;
        }
        catch (Exception ex) { Logger.LogError(ex, $"Failed to fetch RSS feed from {feedUrl}"); return Enumerable.Empty<RssFeedItem>(); }
    }

    private static string StripHtml(string input) => string.IsNullOrEmpty(input) ? string.Empty : System.Text.RegularExpressions.Regex.Replace(input, "<.*?>", string.Empty).Trim();
    private static string HtmlDecode(string input) => string.IsNullOrEmpty(input) ? string.Empty : System.Net.WebUtility.HtmlDecode(input);

    private async Task OnDeleteClick()
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete '{Item.Title}'?");
        if (IsDisposed) return;
        if (confirmed) { await OnItemDeleted.InvokeAsync(Item); }
    }

    private async Task OnEditClick() { await OnItemEdited.InvokeAsync(); }

    private class RssFeedItem { public string Title { get; set; } = string.Empty; public string Link { get; set; } = string.Empty; public string Description { get; set; } = string.Empty; public DateTime PublishDate { get; set; } = DateTime.MinValue; }

    public override void Dispose() { _refreshTimer?.Dispose(); _httpClient?.Dispose(); base.Dispose(); }
}